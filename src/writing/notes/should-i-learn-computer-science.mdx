---
slug: should-i-learn-computer-science
title: Should I learn Computer Science?
planted: May 11, 2024
watered: May 11, 2024
format: Note
status: Seedling
---

Devoting time to self-study Computer Science is a classic debate for the self-taught, bootcamp grad programmer like me. I’ve kicked around versions of this question in my head before, but what really got me thinking critically about it recently is Oz Nova’s [teachyourselfcs.com](https://teachyourselfcs.com/).

I am familiar with Oz from his podcast [CS Primer](https://show.csprimer.com/) with Charlie Harrington. I really like their show—they record highly casual, meandering conversations related to programming education.

## The full curriculum

The teachyourselfcs.com suggested curriculum is no joke. 100-200 hours for each of nine topics. Even if you did 100 hours per subject at a fairly dedicated four hours per week, that would take almost five years! Depending on your job, it’s likely you have more than four hours free per week, but so much competes for those hours: side projects, other learning, writing, reading, cooking, exercising, time with friends, etc.

<Callout>
  Tim Urban’s essay on [how to pick a
  career](https://waitbutwhy.com/2018/04/picking-career.html) visualizes the
  time we have and how we spend it (see "Time Breakdown of a Long Human Life"
  diagram under subheading "The Cook and the Chef"). I like using that framework
  on a smaller scale of days and weeks, counting out how many free hours I
  actually have to allocate.
</Callout>

Without a full time job, the math changes quite a bit, obviously. Like, taking `n` months between jobs and dedicating a large portion of that time to CS sounds more palatable. But I think if I did that I’d rather spend the lion’s share of my time building an ambitious project. The kind of side project you dream about but there simply aren’t enough weekends for. Or join a program like [Recurse](https://www.recurse.com/), where I suppose you could do both.

## Starting smaller

Oz notes that if the full curriculum is too much then you should start with two books:

1. [_Computer Systems: A Programmer’s Perspective_](https://www.goodreads.com/book/show/829182.Computer_Systems)
2. [_Designing Data-Intensive Applications_](https://www.goodreads.com/book/show/23463279-designing-data-intensive-applications)

Those are 562 pages and 978 pages, respectively. That might not intimidate a prolific reader, but I am not a prolific reader. I like to read, and I’ve read a couple thousand(ish) page books, but I’ve also failed to read more than a couple. And it takes a while! Who is a prolific reader? I heard Retool CEO David Hsu [on a podcast](https://podcasts.apple.com/us/podcast/latent-space-the-ai-engineer-podcast-practitioners/id1674008350?i=1000643840574) say that he reads one book a week. He didn’t say audiobook, but maybe that’s it? I do worry about sacrificing understanding and retention with audiobooks, though.

And of course there are countless other well regarded, thick books outside of the nine Oz recommends. Like [_Artificial Intelligence: A Modern Approach_](https://www.goodreads.com/book/show/27543.Artificial_Intelligence) (podcast rec from James Brady who leads engineering at [Elicit](https://elicit.com/)), which is also over a thousand pages.

All that said, I do think reading those books would be worthwhile. _Designing Data-Intensive Applications_ has a 4.71 on Goodreads! That’s an outstanding rating. I read a handful of chapters and did find it interesting, although as a frontend-leaning web developer at the time it felt less relevant to me than it probably would have for someone gearing up to be a CTO at a growing startup.

## The value of pure learning

Pure, academic learning—as opposed to practical, applied learning on actual projects—is engaging but can feel like a waste of precious time. Part of my motivation is to uncover unknown unknowns, i.e. things I don’t know that I don’t know but may come in handy down the road. I don’t feel restricted by my lack of CS knowledge as a web developer right now, but (1) there may come a day when I do feel that limitation, and (2) I might be applying that knowledge day-to-day in ways I can’t even see right now.

My overarching learning strategy on the scale of years and decades is to build a broad base of STEM fundamentals. And not just for work. Learning about human biology and nutrition is useful as a runner, for example. Learning about food chemistry is useful as a casual chef. Learning some mechanics might come in handy when I need to fix my bike. [Brilliant](https://brilliant.org/home/) is great for this sort of learning.

My intention is to allocate most time to short- and medium-term things and smaller chunks of time to this sort of pure learning. Maybe 80/20. And even if certain knowledge doesn’t come in handy at work or in personal pursuits, the act of learning itself is pleasurable.

## Anki

It’s important how you learn, too. Without applying new knowledge, most of what I wrote down while reading Kleppmann’s book has been slowly pruned from my brain. But that was before <Link href="/anki">I started using Anki</Link>, which can make this kind of pure learning more durable.

I like Michael Nielsen’s approach described in his essay [Augmenting Long-Term Memory](https://augmentingcognition.com/ltm.html). He advises reading thick papers outside of your domain expertise in phases and layers: do a quick first read, looking things up now and again but mostly skipping sections that are beyond your depth; make Anki cards for the new concepts you can understand relatively quickly; after building a foundation of knowledge from that paper and related study, do a second pass at the paper; and then a third pass, and so on.

I like this a lot. It’s all about deciding where to draw the line in the sand for abstractions in your mental models. Writing Anki cards helps me with this. I find myself saying in my head, “ok I get the basics, but I don’t know how [that] would be implemented, and I can’t reconcile [this other thing], but that would be too big a rabbit hole for now.”

## Learning CS by learning Rust

The middle ground I’ve settled on for now is to learn some Computer Science concepts while also learning a practical skill—Rust. I’ve <Link href="/hello-rust">just started</Link> learning Rust, and my hope is that I’ll naturally pick up some CS fundamentals as I go along.

After floating that idea in my head, I stumbled upon a testimony of sorts from [Paul Butler on devtools.fm](https://podcasts.apple.com/us/podcast/devtools-fm-developer-tools-open-source-software-development/id1566647758?i=1000579652007) (starts around 28:00):

> It kind of teaches you Computer Science almost as you do it. Like, even though there’s a learning curve with it I always feel like I’ve learned something not just about Rust but about computation when I get past one of those hurdles. So I like that about Rust.”

[The Rust book](https://rust-book.cs.brown.edu/ch00-00-introduction.html) itself even advertises a similar goal in learning the language:

> Rust is for students and those who are interested in learning about systems concepts. Using Rust, many people have learned about topics like operating systems development.

I’ll start with Rust and go from there.
